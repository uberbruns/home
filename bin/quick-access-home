#!/opt/homebrew/bin/fish

# ── Docs ─────────────────────────────────────────────────────────

# Quick-access launcher combining macOS apps and registered actions.
# Presents a unified fzf index; selecting an item runs its action.
# Escape exits; returning from a sub-picker loops back to home.
#
# Index format: <search key> \t <display> \t <action>


# ── Config ───────────────────────────────────────────────────────

set line_width 84
set max_details_width 40
set max_path_depth 5


# ── Implementation ──────────────────────────────────────────────

# Aggregates all index sources into a unified list.
function make_index
    make_action_index
    make_app_index
end

# Builds index rows from registered actions.
function make_action_index
    set -l entries \
        "Show Clipboard History" "clipse" "quick-access-clipboard" "and exit" \
        "Open Editor" "fresh" "fresh" "exit" \
        "Calculate" "qalc" "qalc" "exit" \
        "Browse Files" "yazi" "yazi" "exit" \
        "Run Swift REPL" "swift" "swift repl" "exit"

    for i in (seq 1 4 (count $entries))
        set name $entries[$i]
        set description $entries[(math $i + 1)]
        set command $entries[(math $i + 2)]
        set suffix $entries[(math $i + 3)]

        # Skip entries whose command is not installed
        if not command -q (string split ' ' -- $command)[1]
            continue
        end

        # Build action string with optional exit suffix
        set action $command
        if test -n "$suffix"
            set action "$command; $suffix"
        end

        # Build index row
        set display (format_row "Action" "32" $name $description)
        printf '%s\t%s\t%s\n' $name $display $action
    end
end

# Builds index rows from macOS apps found via Spotlight.
function make_app_index
    # Find app paths, filtering by depth and excluding nested bundles
    set app_paths (mdfind 'kMDItemContentType == "com.apple.application-bundle"' \
        | grep -E "^(/[^/]+){1,$max_path_depth}\$" \
        | grep -v '/[^/]*\.[^/]*/.*\.app$' \
        | sort)

    for app_path in $app_paths
        # Extract components
        set app_dir (string replace -r '/[^/]+$' '' -- $app_path)
        set app_name (string replace -r '.*/(.+)\.app$' '$1' -- $app_path)

        # Build index row
        set display (format_row "App" "34" $app_name $app_dir)
        printf '%s\t%s\t%s\n' $app_path $display "open '$app_path'; exit"
    end
end


# ── Supporting Code ─────────────────────────────────────────────

# Formats a row with colored type tag, title, and right-aligned details.
function format_row --argument-names type_label type_color title details
    # Truncate details
    if test (string length -- $details) -gt $max_details_width
        set details (string sub -l (math $max_details_width - 2) -- $details)..
    end

    # Build colored type tag
    set tag (printf '\e[%sm[%s]\e[0m' $type_color $type_label)
    set tag_len (math 2 + (string length -- $type_label))

    # Calculate padding between title and details
    set details_len (string length -- $details)
    set title_len (string length -- $title)
    set padding_len (math "$line_width - $tag_len - 1 - $title_len - $details_len")
    if test $padding_len -lt 1
        set padding_len 1
    end
    set padding (string repeat -n $padding_len ' ')

    # Compose row
    printf '%s %s%s\e[90m%s\e[0m' $tag $title $padding $details
end


# ── Main ─────────────────────────────────────────────────────────

cd ~
while true
    set selection (make_index | fzf --ansi --prompt="❯ " --no-hscroll --border=bold \
        --delimiter='\t' --nth=1 --with-nth=2 -i \
        --bind "enter:accept")
    if test -z "$selection"
        exit
    end
    eval (string split \t -- $selection)[3]
end
